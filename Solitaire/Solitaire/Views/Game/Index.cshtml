@using System.Linq
@using Solitaire.Models.models
@model GameViewModel
@{
    ViewData["Title"] = "Solitaire";
}

<div class="container">
    <h1>Solitaire Game</h1>

    <div class="row mb-4">
        <div class="col-md-12">
            <button id="newGame" class="btn btn-primary">New Game</button>
            <button id="drawCard" class="btn btn-success">Draw Card</button>
            <span id="gameStatus" class="ml-3"></span>
        </div>
    </div>

    <!-- Stock and Waste -->
    <div class="row mb-4">
        <div class="col-md-2">
            <div class="card-area">
                <h5>Stock: <span id="stockCount">@Model.StockCount</span></h5>
                <div class="card-slot stock-pile" id="stockPile">
                    @if (Model.StockCount > 0)
                    {
                        <div class="card back">🂠</div>
                    }
                    else
                    {
                        <div class="empty-slot">♻️</div>
                    }
                </div>
            </div>
        </div>
        <div class="col-md-2">
            <div class="card-area">
                <h5>Waste</h5>
                <div class="card-slot waste-area" id="wasteArea">
                    @if (Model.Waste.Count > 0)
                    {
                        var topCard = Model.Waste[Model.Waste.Count - 1];
                        <div class="card front @topCard.Suit.ToLower() @topCard.Color.ToLower() waste-card"
                             draggable="true"
                             data-rank="@topCard.Rank"
                             data-suit="@topCard.Suit"
                             data-color="@topCard.Color"
                             data-source="waste"
                             data-faceup="true">
                            <span class="card-value">@GetRankSymbol(topCard.Rank)@GetSuitSymbol(topCard.Suit)</span>
                        </div>
                    }
                </div>
            </div>
        </div>
        <div class="col-md-8">
            <div class="card-area">
                <h5>Foundations</h5>
                <div class="foundations" id="foundationsArea">
                    @foreach (var foundation in Model.Foundations)
                    {
                        <div class="card-slot foundation drop-target" data-suit="@foundation.Key" data-target="foundation">
                            @if (foundation.Value.Count > 0)
                            {
                                var topCard = foundation.Value[foundation.Value.Count - 1];
                                <div class="card front @topCard.Suit.ToLower() @topCard.Color.ToLower()"
                                     data-rank="@topCard.Rank"
                                     data-suit="@topCard.Suit"
                                     data-color="@topCard.Color">
                                    <span class="card-value">@GetRankSymbol(topCard.Rank)@GetSuitSymbol(topCard.Suit)</span>
                                </div>
                            }
                            else
                            {
                                <div class="empty-foundation">@GetSuitSymbol(foundation.Key)</div>
                            }
                        </div>
                    }
                </div>
            </div>
        </div>
    </div>

    <!-- Tableau -->
    <div class="row">
        <div class="col-md-12">
            <div class="tableau" id="tableauArea">
                @for (int i = 0; i < Model.Tableau.Count; i++)
                {
                    <div class="tableau-column drop-target" data-column="@i" data-target="tableau">
                        @{
                            var column = Model.Tableau[i];
                            var cardIndex = 0;
                        }
                        @if (column.Count == 0)
                        {
                            <div class="empty-tableau">K</div>
                        }
                        @foreach (var card in column)
                        {
                            if (card.IsFaceUp)
                            {
                                <div class="card front draggable @card.Suit.ToLower() @card.Color.ToLower()"
                                     draggable="true"
                                     data-rank="@card.Rank"
                                     data-suit="@card.Suit"
                                     data-color="@card.Color"
                                     data-column="@i"
                                     data-index="@cardIndex"
                                     data-source="tableau"
                                     data-faceup="true">
                                    <span class="card-value">@GetRankSymbol(card.Rank)@GetSuitSymbol(card.Suit)</span>
                                </div>
                            }
                            else
                            {
                                <div class="card back"
                                     data-rank="@card.Rank"
                                     data-suit="@card.Suit"
                                     data-color="@card.Color"
                                     data-column="@i"
                                     data-index="@cardIndex"
                                     data-source="tableau"
                                     data-faceup="false">
                                    <span class="card-back-symbol">🂠</span>
                                </div>
                            }
                            cardIndex++;
                        }
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@section Styles {
    <style>
        .container, .card, .card-value, .card-slot,
        .tableau-column, .foundations, .card-area,
        .card-back-symbol, .empty-foundation, .empty-tableau {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .card-slot {
            width: 100px;
            height: 140px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 5px;
            transition: all 0.2s;
        }

        .stock-pile {
            cursor: pointer;
        }

            .stock-pile:hover {
                border-color: #28a745;
                background-color: rgba(40, 167, 69, 0.1);
                transform: scale(1.05);
            }

        .empty-slot {
            font-size: 40px;
            color: #999;
            pointer-events: none;
        }

        .drop-target.drag-over {
            border-color: #28a745 !important;
            background-color: rgba(40, 167, 69, 0.3) !important;
            border-width: 3px !important;
        }

        .card {
            width: 100px;
            height: 140px;
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            padding: 8px;
            font-size: 24px;
            margin-bottom: -120px;
            transition: all 0.15s ease;
            position: relative;
            z-index: 1;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.2);
        }

            .card.front.draggable {
                cursor: grab;
                background: white;
            }

                .card.front.draggable:hover {
                    transform: translateY(-10px);
                    z-index: 100;
                    box-shadow: 0 8px 20px rgba(0,0,0,0.4);
                    border-color: #007bff;
                    border-width: 3px;
                }

                .card.front.draggable:active {
                    cursor: grabbing;
                }

            .card.dragging {
                opacity: 0.5;
                cursor: grabbing !important;
                z-index: 1000;
            }

            .card.back {
                background: linear-gradient(135deg, #1e5a1e, #2d8a2d);
                color: white;
                align-items: center;
                justify-content: center;
                cursor: default;
                border-color: #1e5a1e;
            }

                .card.back:hover {
                    transform: none;
                    box-shadow: 2px 2px 8px rgba(0,0,0,0.2);
                }

        .card-value {
            font-size: 22px;
            font-weight: bold;
            text-align: center;
            width: 100%;
            line-height: 1.3;
            pointer-events: none;
        }

        .card-back-symbol {
            font-size: 50px;
            pointer-events: none;
        }

        .card.front.red,
        .card.front.hearts,
        .card.front.diamonds {
            color: #dc143c !important;
        }

        .card.front.black,
        .card.front.clubs,
        .card.front.spades {
            color: #000000 !important;
        }

        .tableau {
            display: flex;
            gap: 15px;
            padding: 20px 0;
        }

        .tableau-column {
            min-width: 110px;
            min-height: 200px;
            padding: 10px;
            border-radius: 8px;
            border: 2px dashed transparent;
            transition: all 0.2s;
        }

        .foundations {
            display: flex;
            gap: 10px;
        }

        .empty-foundation,
        .empty-tableau {
            font-size: 32px;
            color: #aaa;
            font-weight: bold;
            pointer-events: none;
        }

        #gameStatus {
            font-weight: bold;
            font-size: 20px;
        }
    </style>
}

@section Scripts {
    <script>
        let draggedCard = null;

        function getRankSymbol(rank) {
            const symbols = { 1: 'A', 11: 'J', 12: 'Q', 13: 'K' };
            return symbols[rank] || rank.toString();
        }

        function getSuitSymbol(suit) {
            const symbols = {
                'hearts': '♥',
                'diamonds': '♦',
                'clubs': '♣',
                'spades': '♠'
            };
            return symbols[suit.toLowerCase()] || suit[0].toUpperCase();
        }

        // ✅ UPDATE GAME STATE WITHOUT RELOAD
        function updateGameState(gameState) {
            console.log('📊 Updating game state:', gameState);

            // Update stock count
            $('#stockCount').text(gameState.stockCount);

            // Update stock pile
            $('#stockPile').html(
                gameState.stockCount > 0
                    ? '<div class="card back">🂠</div>'
                    : '<div class="empty-slot">♻️</div>'
            );

            // Update waste pile
            $('#wasteArea').empty();
            if (gameState.waste && gameState.waste.length > 0) {
                const topCard = gameState.waste[gameState.waste.length - 1];
                const colorClass = (topCard.suit === 'hearts' || topCard.suit === 'diamonds') ? 'red' : 'black';
                $('#wasteArea').append(`
                    <div class="card front ${topCard.suit.toLowerCase()} ${colorClass} waste-card"
                         draggable="true"
                         data-rank="${topCard.rank}"
                         data-suit="${topCard.suit}"
                         data-color="${topCard.color}"
                         data-source="waste"
                         data-faceup="true">
                        <span class="card-value">${getRankSymbol(topCard.rank)}${getSuitSymbol(topCard.suit)}</span>
                    </div>
                `);
            }

            // Update foundations
            $('#foundationsArea .foundation').each(function() {
                const suit = $(this).attr('data-suit');
                const foundation = gameState.foundations[suit];

                $(this).empty();
                if (foundation && foundation.length > 0) {
                    const topCard = foundation[foundation.length - 1];
                    const colorClass = (topCard.suit === 'hearts' || topCard.suit === 'diamonds') ? 'red' : 'black';
                    $(this).append(`
                        <div class="card front ${topCard.suit.toLowerCase()} ${colorClass}"
                             data-rank="${topCard.rank}"
                             data-suit="${topCard.suit}"
                             data-color="${topCard.color}">
                            <span class="card-value">${getRankSymbol(topCard.rank)}${getSuitSymbol(topCard.suit)}</span>
                        </div>
                    `);
                } else {
                    $(this).append(`<div class="empty-foundation">${getSuitSymbol(suit)}</div>`);
                }
            });

            // Update tableau
            $('#tableauArea .tableau-column').each(function(colIndex) {
                const column = gameState.tableau[colIndex];
                $(this).empty();

                if (!column || column.length === 0) {
                    $(this).append('<div class="empty-tableau">K</div>');
                } else {
                    column.forEach((card, cardIndex) => {
                        const colorClass = (card.suit === 'hearts' || card.suit === 'diamonds') ? 'red' : 'black';
                        if (card.isFaceUp) {
                            $(this).append(`
                                <div class="card front draggable ${card.suit.toLowerCase()} ${colorClass}"
                                     draggable="true"
                                     data-rank="${card.rank}"
                                     data-suit="${card.suit}"
                                     data-color="${card.color}"
                                     data-column="${colIndex}"
                                     data-index="${cardIndex}"
                                     data-source="tableau"
                                     data-faceup="true">
                                    <span class="card-value">${getRankSymbol(card.rank)}${getSuitSymbol(card.suit)}</span>
                                </div>
                            `);
                        } else {
                            $(this).append(`
                                <div class="card back"
                                     data-rank="${card.rank}"
                                     data-suit="${card.suit}"
                                     data-color="${card.color}"
                                     data-column="${colIndex}"
                                     data-index="${cardIndex}"
                                     data-source="tableau"
                                     data-faceup="false">
                                    <span class="card-back-symbol">🂠</span>
                                </div>
                            `);
                        }
                    });
                }
            });

            // Check win condition
            if (gameState.isGameWon) {
                $('#gameStatus').html('<span class="text-success">🎉 You Won!</span>');
                setTimeout(() => {
                    if (confirm('Congratulations! Play again?')) {
                        $('#newGame').click();
                    }
                }, 500);
            }
        }

        // ✅ MAKE MOVE WITHOUT RELOAD
        function makeMove(moveData) {
            console.log('🎯 Making move:', moveData);

            $.ajax({
                url: '/Game/MakeMove',
                type: 'POST',
                contentType: 'application/json',
                data: JSON.stringify(moveData),
                success: function(response) {
                    console.log('📥 Response:', response);

                    if (response.success) {
                        console.log('✅ Move successful - updating display');
                        updateGameState(response.gameState);
                    } else {
                        console.log('❌ Move failed:', response.error);
                        alert('Invalid move!');
                    }
                },
                error: function(xhr, status, error) {
                    console.error('❌ AJAX Error:', error);
                    alert('Error making move');
                }
            });
        }

        // NEW GAME
        $('#newGame').click(function() {
            console.log('🆕 New game');
            $.post('/Game/NewGame', function(response) {
                if (response.success) {
                    location.reload(); // Only reload for new game
                }
            });
        });

        // DRAW CARD
        $('#drawCard').click(function() {
            console.log('🎴 Draw card button');
            makeMove({ moveType: 'draw' });
        });

        // STOCK PILE CLICK
        $('#stockPile').click(function() {
            console.log('🎴 Stock pile clicked');
            makeMove({ moveType: 'draw' });
        });

        // ========== DRAG AND DROP ==========

        $(document).on('dragstart', '.card[draggable="true"]', function(e) {
            if ($(this).attr('data-faceup') !== 'true') {
                e.preventDefault();
                return false;
            }

            $(this).addClass('dragging');

            draggedCard = {
                rank: parseInt($(this).attr('data-rank')),
                suit: $(this).attr('data-suit'),
                color: $(this).attr('data-color'),
                source: $(this).attr('data-source'),
                column: $(this).attr('data-column') ? parseInt($(this).attr('data-column')) : null,
                index: $(this).attr('data-index') ? parseInt($(this).attr('data-index')) : null
            };

            console.log('🚀 Dragging:', draggedCard);

            e.originalEvent.dataTransfer.effectAllowed = 'move';
            e.originalEvent.dataTransfer.setData('text/plain', '');
        });

        $(document).on('dragend', '.card[draggable="true"]', function() {
            $(this).removeClass('dragging');
            $('.drop-target').removeClass('drag-over');
        });

        $('.drop-target').on('dragover', function(e) {
            e.preventDefault();
            return false;
        });

        $('.drop-target').on('dragenter', function(e) {
            e.preventDefault();
            $(this).addClass('drag-over');
        });

        $('.drop-target').on('dragleave', function(e) {
            const rect = this.getBoundingClientRect();
            const x = e.originalEvent.clientX;
            const y = e.originalEvent.clientY;

            if (x <= rect.left || x >= rect.right || y <= rect.top || y >= rect.bottom) {
                $(this).removeClass('drag-over');
            }
        });

        $('.drop-target').on('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();

            $(this).removeClass('drag-over');

            if (!draggedCard) return false;

            const targetType = $(this).attr('data-target');
            let moveData = {};

            if (targetType === 'foundation') {
                const foundationSuit = $(this).attr('data-suit');

                if (draggedCard.source === 'waste') {
                    moveData = {
                        moveType: 'waste_to_foundation',
                        foundationSuit: foundationSuit
                    };
                } else if (draggedCard.source === 'tableau') {
                    moveData = {
                        moveType: 'tableau_to_foundation',
                        foundationSuit: foundationSuit,
                        fromColumn: draggedCard.column,
                        cardIndex: draggedCard.index
                    };
                }
            } else if (targetType === 'tableau') {
                const targetColumn = parseInt($(this).attr('data-column'));

                if (draggedCard.source === 'waste') {
                    moveData = {
                        moveType: 'waste_to_tableau',
                        toColumn: targetColumn
                    };
                } else if (draggedCard.source === 'tableau') {
                    if (draggedCard.column === targetColumn) {
                        return false;
                    }

                    moveData = {
                        moveType: 'tableau_to_tableau',
                        fromColumn: draggedCard.column,
                        toColumn: targetColumn,
                        cardIndex: draggedCard.index
                    };
                }
            }

            if (Object.keys(moveData).length > 0) {
                console.log('✅ Valid drop');
                makeMove(moveData);
            }

            draggedCard = null;
            return false;
        });

        // DOUBLE CLICK
        $(document).on('dblclick', '.card[draggable="true"]', function() {
            if ($(this).attr('data-faceup') !== 'true') return;

            const suit = $(this).attr('data-suit');
            const source = $(this).attr('data-source');
            let moveData = {};

            if (source === 'waste') {
                moveData = {
                    moveType: 'waste_to_foundation',
                    foundationSuit: suit
                };
            } else if (source === 'tableau') {
                moveData = {
                    moveType: 'tableau_to_foundation',
                    foundationSuit: suit,
                    fromColumn: parseInt($(this).attr('data-column')),
                    cardIndex: parseInt($(this).attr('data-index'))
                };
            }

            if (Object.keys(moveData).length > 0) {
                makeMove(moveData);
            }
        });

        console.log('✅ Game ready - no reloads on moves!');
    </script>
}

@functions {
    private string GetRankSymbol(int rank)
    {
        return rank switch
        {
            1 => "A",
            11 => "J",
            12 => "Q",
            13 => "K",
            _ => rank.ToString()
        };
    }

    private string GetSuitSymbol(string suit)
    {
        return suit.ToLower() switch
        {
            "hearts" => "♥",
            "diamonds" => "♦",
            "clubs" => "♣",
            "spades" => "♠",
            _ => suit[0].ToString().ToUpper()
        };
    }
}