@using System.Linq
@using Solitaire.Models.models
@model GameViewModel
@{
    ViewData["Title"] = "Solitaire";
}

<div class="container">
    <h1>Solitaire</h1>

    <div class="row mb-4">
        <div class="col-md-12">
            <button id="newGame" class="btn btn-primary">New Game</button>
            <button id="drawCard" class="btn btn-success">Draw Card</button>
            <span id="gameStatus" class="ml-3"></span>
        </div>
    </div>

    <!-- Stock and Waste -->
    <div class="row mb-4">
        <div class="col-md-2">
            <div class="card-area">
                <h5>Stock: @Model.StockCount</h5>
                <div class="card-slot stock" data-action="draw">
                    @if (Model.StockCount > 0)
                    {
                        <div class="card back">🂠</div>
                    }
                </div>
            </div>
        </div>
        <div class="col-md-2">
            <div class="card-area">
                <h5>Waste</h5>
                <div class="card-slot waste">
                    @if (Model.Waste.Count > 0)
                    {
                        var topCard = Model.Waste[Model.Waste.Count - 1];
                        <div class="card front @topCard.Suit.ToLower() @topCard.Color.ToLower() waste-card"
                             draggable="true"
                             data-rank="@topCard.Rank"
                             data-suit="@topCard.Suit"
                             data-color="@topCard.Color"
                             data-source="waste">
                            <span class="card-value">@GetRankSymbol(topCard.Rank)@GetSuitSymbol(topCard.Suit)</span>
                        </div>
                    }
                </div>
            </div>
        </div>
        <div class="col-md-8">
            <div class="card-area">
                <h5>Foundations</h5>
                <div class="foundations">
                    @foreach (var foundation in Model.Foundations)
                    {
                        <div class="card-slot foundation drop-target" data-suit="@foundation.Key" data-target="foundation">
                            @if (foundation.Value.Count > 0)
                            {
                                var topCard = foundation.Value[foundation.Value.Count - 1];
                                <div class="card front @topCard.Suit.ToLower() @topCard.Color.ToLower()"
                                     data-rank="@topCard.Rank"
                                     data-suit="@topCard.Suit"
                                     data-color="@topCard.Color">
                                    <span class="card-value">@GetRankSymbol(topCard.Rank)@GetSuitSymbol(topCard.Suit)</span>
                                </div>
                            }
                            else
                            {
                                <div class="empty-foundation">@foundation.Key[0]</div>
                            }
                        </div>
                    }
                </div>
            </div>
        </div>
    </div>

    <!-- Tableau -->
    <div class="row">
        <div class="col-md-12">
            <div class="tableau">
                @for (int i = 0; i < Model.Tableau.Count; i++)
                {
                    <div class="tableau-column drop-target" data-column="@i" data-target="tableau">
                        @{
                            var column = Model.Tableau[i];
                            var cardIndex = 0;
                        }
                        @foreach (var card in column)
                        {
                            <div class="card @(card.IsFaceUp ? "front " + card.Suit.ToLower() + " " + card.Color.ToLower() : "back")"
                            @(card.IsFaceUp ? "draggable='true'" : "")
                                 data-rank="@card.Rank"
                                 data-suit="@card.Suit"
                                 data-color="@card.Color"
                                 data-column="@i"
                                 data-index="@cardIndex"
                                 data-source="tableau">
                                @if (card.IsFaceUp)
                                {
                                    <span class="card-value">@GetRankSymbol(card.Rank)@GetSuitSymbol(card.Suit)</span>
                                }
                                else
                                {
                                    <span class="card-back-symbol">🂠</span>
                                }
                            </div>
                            cardIndex++;
                        }
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@section Styles {
    <style>
        .card-slot {
            width: 100px;
            height: 140px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

            .card-slot:hover {
                border-color: #007bff;
                background-color: rgba(0, 123, 255, 0.1);
            }

            .card-slot.drag-over {
                border-color: #28a745;
                background-color: rgba(40, 167, 69, 0.2);
                border-width: 3px;
            }

        /* UPDATED: Card layout with top-aligned content */
        .card {
            width: 100px;
            height: 140px;
            border: 1px solid #000;
            border-radius: 8px;
            display: flex;
            flex-direction: column; /* UPDATED: Changed to column layout */
            align-items: flex-start; /* UPDATED: Align to start (top) */
            justify-content: flex-start; /* UPDATED: Start from top */
            padding: 5px 8px; /* UPDATED: Added padding */
            font-size: 24px;
            margin-bottom: -120px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            z-index: 1;
        }

            .card:hover {
                transform: translateY(-5px);
                z-index: 10;
            }

            .card.selected {
                box-shadow: 0 0 0 3px yellow;
                transform: scale(1.05);
                z-index: 20;
            }

            .card.dragging {
                opacity: 0.5;
                cursor: move;
            }

            .card.back {
                background: linear-gradient(45deg, #1a6a1a, #2d8a2d);
                color: white;
                align-items: center; /* UPDATED: Center for back cards */
                justify-content: center; /* UPDATED: Center for back cards */
            }

            .card.front {
                background: white;
                box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
                color: black;
            }

        /* UPDATED: Card value positioning at top center */
        .card-value {
            font-size: 20px; /* UPDATED: Slightly smaller font */
            font-weight: bold;
            text-align: center;
            width: 100%; /* UPDATED: Full width for centering */
            line-height: 1.2;
        }

        .card-back-symbol {
            font-size: 50px; /* UPDATED: Large symbol for back */
        }

        /* UPDATED: Fixed color classes */
        .card.front.red,
        .card.front.hearts,
        .card.front.diamonds {
            color: #dc143c !important;
        }

        .card.front.black,
        .card.front.clubs,
        .card.front.spades {
            color: #000000 !important;
        }

        .tableau {
            display: flex;
            gap: 20px;
        }

        .tableau-column {
            min-width: 100px;
            min-height: 200px;
            padding-top: 20px;
        }

            .tableau-column.drag-over {
                background-color: rgba(40, 167, 69, 0.1);
                border: 2px dashed #28a745;
                border-radius: 8px;
            }

        .foundations {
            display: flex;
            gap: 10px;
        }

        .empty-foundation {
            font-size: 18px;
            color: #666;
            font-weight: bold;
        }

        #gameStatus {
            font-weight: bold;
            font-size: 18px;
        }
    </style>
}

@section Scripts {
    <script>
        let selectedCard = null;
        let selectedWaste = false;
        let draggedCard = null;

        // FIXED: Only reload on successful moves, not on errors
        function makeMove(moveData) {
            console.log('Making move:', moveData);
            $.ajax({
                url: '@Url.Action("MakeMove", "Game")',
                method: 'POST',
                contentType: 'application/json',
                data: JSON.stringify(moveData),
                success: function(response) {
                    console.log('Response:', response);
                    if (response.success) {
                        console.log('✅ Move successful, reloading...');
                        location.reload(); // FIXED: Only reload on success
                    } else {
                        console.log('❌ Move failed:', response.error);
                        if (!moveData.isAutoMove) {
                            alert('Invalid move: ' + (response.error || 'Move not allowed'));
                        }
                        // FIXED: Don't reload on failure!
                    }
                },
                error: function(xhr, status, error) {
                    console.error('AJAX Error:', status, error);
                    if (!moveData.isAutoMove) {
                        alert('Error: Could not complete move');
                    }
                    // FIXED: Don't reload on error!
                }
            });
        }

        function drawFromStock() {
            console.log('Drawing from stock...');
            makeMove({ moveType: 'draw' });
        }

        function handleCardClick(cardElement) {
            const card = $(cardElement);

            if (card.hasClass('back')) {
                return;
            }

            $('.card.selected').removeClass('selected');
            selectedWaste = false;

            if (selectedCard && selectedCard.element === cardElement) {
                selectedCard = null;
            } else {
                card.addClass('selected');
                selectedCard = {
                    element: cardElement,
                    column: parseInt(card.data('column')),
                    index: parseInt(card.data('index')),
                    rank: parseInt(card.data('rank')),
                    suit: card.data('suit'),
                    source: card.data('source')
                };
                console.log('Selected card:', selectedCard);
            }
        }

        function selectWaste() {
            if ($('.waste-card').length === 0) return;

            $('.card.selected').removeClass('selected');
            $('.waste-card').addClass('selected');
            selectedCard = null;
            selectedWaste = true;
            console.log('Selected waste card');
        }

        function moveToFoundation(suit) {
            let moveData = {};

            if (selectedWaste) {
                moveData = {
                    moveType: 'waste_to_foundation',
                    foundationSuit: suit
                };
            } else if (selectedCard) {
                moveData = {
                    moveType: 'tableau_to_foundation',
                    foundationSuit: suit,
                    fromColumn: selectedCard.column,
                    cardIndex: selectedCard.index
                };
            } else {
                return;
            }

            makeMove(moveData);
        }

        function moveToTableau(columnIndex) {
            let moveData = {};

            if (selectedWaste) {
                moveData = {
                    moveType: 'waste_to_tableau',
                    toColumn: columnIndex
                };
            } else if (selectedCard) {
                if (selectedCard.column === columnIndex) {
                    return;
                }

                moveData = {
                    moveType: 'tableau_to_tableau',
                    fromColumn: selectedCard.column,
                    toColumn: columnIndex,
                    cardIndex: selectedCard.index
                };
            } else {
                return;
            }

            makeMove(moveData);
        }

        function handleDoubleClick(cardElement) {
            const card = $(cardElement);

            if (card.hasClass('back')) {
                return;
            }

            console.log('Double-click detected');

            const rank = parseInt(card.data('rank'));
            const suit = card.data('suit');
            const source = card.data('source');

            if (source === 'waste') {
                makeMove({
                    moveType: 'waste_to_foundation',
                    foundationSuit: suit,
                    isAutoMove: true
                });
            } else if (source === 'tableau') {
                const columnIndex = parseInt(card.data('column'));
                const cardIndex = parseInt(card.data('index'));

                tryMoveToFoundation(columnIndex, cardIndex, suit, rank);
            }
        }

        function tryMoveToFoundation(columnIndex, cardIndex, cardSuit, cardRank) {
            const moveData = {
                moveType: 'tableau_to_foundation',
                foundationSuit: cardSuit,
                fromColumn: columnIndex,
                cardIndex: cardIndex,
                isAutoMove: true
            };

            $.ajax({
                url: '@Url.Action("MakeMove", "Game")',
                method: 'POST',
                contentType: 'application/json',
                data: JSON.stringify(moveData),
                success: function(response) {
                    if (response.success) {
                        location.reload();
                    } else {
                        tryMoveToTableau(columnIndex, cardIndex, cardRank, cardSuit);
                    }
                }
            });
        }

        function tryMoveToTableau(columnIndex, cardIndex, cardRank, cardSuit) {
            const cardColor = (cardSuit === 'hearts' || cardSuit === 'diamonds') ? 'red' : 'black';

            for (let targetColumn = 0; targetColumn < 7; targetColumn++) {
                if (targetColumn === columnIndex) continue;

                const targetColumnElement = $(`.tableau-column[data-column="${targetColumn}"]`);
                const targetCards = targetColumnElement.find('.card.front');

                if (targetCards.length === 0) {
                    if (cardRank === 13) {
                        makeTableauMove(columnIndex, targetColumn, cardIndex);
                        return;
                    }
                } else {
                    const topCard = targetCards.last();
                    const topRank = parseInt(topCard.data('rank'));
                    const topSuit = topCard.data('suit');
                    const topColor = (topSuit === 'hearts' || topSuit === 'diamonds') ? 'red' : 'black';

                    if (topColor !== cardColor && cardRank === topRank - 1) {
                        makeTableauMove(columnIndex, targetColumn, cardIndex);
                        return;
                    }
                }
            }
        }

        function makeTableauMove(fromColumn, toColumn, cardIndex) {
            makeMove({
                moveType: 'tableau_to_tableau',
                fromColumn: fromColumn,
                toColumn: toColumn,
                cardIndex: cardIndex,
                isAutoMove: true
            });
        }

        // ========== DRAG AND DROP ==========

        function handleDragStart(e) {
            const card = $(e.target);

            if (card.hasClass('back')) {
                e.preventDefault();
                return;
            }

            card.addClass('dragging');

            draggedCard = {
                element: e.target,
                rank: parseInt(card.data('rank')),
                suit: card.data('suit'),
                color: card.data('color'),
                source: card.data('source'),
                column: parseInt(card.data('column')),
                index: parseInt(card.data('index'))
            };

            console.log('Drag started:', draggedCard);

            e.originalEvent.dataTransfer.effectAllowed = 'move';
            e.originalEvent.dataTransfer.setData('text/html', e.target.innerHTML);
        }

        function handleDragEnd(e) {
            $(e.target).removeClass('dragging');
            $('.drop-target').removeClass('drag-over');
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.originalEvent.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            $(e.currentTarget).addClass('drag-over');
        }

        function handleDragLeave(e) {
            $(e.currentTarget).removeClass('drag-over');
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            $(e.currentTarget).removeClass('drag-over');

            if (!draggedCard) return false;

            const dropTarget = $(e.currentTarget);
            const targetType = dropTarget.data('target');

            let moveData = {};

            if (targetType === 'foundation') {
                const foundationSuit = dropTarget.data('suit');

                if (draggedCard.source === 'waste') {
                    moveData = {
                        moveType: 'waste_to_foundation',
                        foundationSuit: foundationSuit
                    };
                } else if (draggedCard.source === 'tableau') {
                    moveData = {
                        moveType: 'tableau_to_foundation',
                        foundationSuit: foundationSuit,
                        fromColumn: draggedCard.column,
                        cardIndex: draggedCard.index
                    };
                }
            } else if (targetType === 'tableau') {
                const targetColumn = parseInt(dropTarget.data('column'));

                if (draggedCard.source === 'waste') {
                    moveData = {
                        moveType: 'waste_to_tableau',
                        toColumn: targetColumn
                    };
                } else if (draggedCard.source === 'tableau') {
                    if (draggedCard.column === targetColumn) {
                        console.log('Cannot drop on same column');
                        return false;
                    }

                    moveData = {
                        moveType: 'tableau_to_tableau',
                        fromColumn: draggedCard.column,
                        toColumn: targetColumn,
                        cardIndex: draggedCard.index
                    };
                }
            }

            if (Object.keys(moveData).length > 0) {
                makeMove(moveData);
            }

            draggedCard = null;
            return false;
        }

        // ========== INITIALIZATION ==========

        $(document).ready(function() {
            console.log('🎮 Initializing Solitaire...');

            $('#newGame').off('click').on('click', function() {
                console.log('Starting new game...');
                $.ajax({
                    url: '@Url.Action("NewGame", "Game")',
                    method: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify({}),
                    success: function(response) {
                        if (response.success) {
                            location.reload();
                        }
                    }
                });
            });

            $('#drawCard').off('click').on('click', function() {
                drawFromStock();
            });

            $('.stock').off('click').on('click', function() {
                drawFromStock();
            });

            $('.card.front').off('click').on('click', function(e) {
                e.stopPropagation();
                handleCardClick(this);
            });

            $('.card.front').off('dblclick').on('dblclick', function(e) {
                e.stopPropagation();
                handleDoubleClick(this);
            });

            $('.foundation').off('click').on('click', function(e) {
                const suit = $(this).data('suit');
                moveToFoundation(suit);
            });

            $('.tableau-column').off('click').on('click', function(e) {
                if ($(e.target).hasClass('tableau-column')) {
                    const column = parseInt($(this).data('column'));
                    moveToTableau(column);
                }
            });

            $('.card[draggable="true"]').on('dragstart', handleDragStart);
            $('.card[draggable="true"]').on('dragend', handleDragEnd);

            $('.drop-target').on('dragover', handleDragOver);
            $('.drop-target').on('dragenter', handleDragEnter);
            $('.drop-target').on('dragleave', handleDragLeave);
            $('.drop-target').on('drop', handleDrop);

            $(document).off('keypress').on('keypress', function(e) {
                if (e.which === 100 || e.which === 68) {
                    drawFromStock();
                } else if (e.which === 110 || e.which === 78) {
                    $('#newGame').click();
                }
            });

        @if (Model.IsGameWon)
        {
            <text>
                    $('#gameStatus').html('<span class="text-success">🎉 You Won!</span>');
                    setTimeout(() => {
                        if (confirm('Congratulations! Start a new game?')) {
                            $('#newGame').click();
                        }
                    }, 500);
            </text>
        }

            console.log('✅ Game ready!');
        });
    </script>
}

@functions {
    private string GetRankSymbol(int rank)
    {
        var symbols = new Dictionary<int, string>
        {
            {1, "A"}, {11, "J"}, {12, "Q"}, {13, "K"}
        };
        return symbols.ContainsKey(rank) ? symbols[rank] : rank.ToString();
    }

    private string GetSuitSymbol(string suit)
    {
        var symbols = new Dictionary<string, string>
        {
            {"hearts", "♥"}, {"diamonds", "♦"}, {"clubs", "♣"}, {"spades", "♠"}
        };
        return symbols.ContainsKey(suit.ToLower()) ? symbols[suit.ToLower()] : suit[0].ToString().ToUpper();
    }
}